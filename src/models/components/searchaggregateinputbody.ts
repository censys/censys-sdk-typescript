/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

export type SearchAggregateInputBody = {
  /**
   * field to aggregate by
   */
  field: string;
  /**
   * Controls whether aggregation results are limited to values that match the query. When true, only field values that satisfy the query constraints are included in aggregation counts. When false, aggregation includes all field values from records that match the query, even if those specific field values don't match the query constraints. For example, if the query is 'host.services.protocol=SSH' and you are aggregating by 'host.services.port' - when true, only shows SSH ports; when false, shows all ports on hosts that have SSH services.
   */
  filterByQuery?: boolean | undefined;
  /**
   * number of buckets to split results into
   */
  numberOfBuckets: number;
  /**
   * CenQL query string to search upon
   */
  query: string;
};

/** @internal */
export const SearchAggregateInputBody$inboundSchema: z.ZodType<
  SearchAggregateInputBody,
  z.ZodTypeDef,
  unknown
> = z.object({
  field: z.string(),
  filter_by_query: z.boolean().default(false),
  number_of_buckets: z.number().int(),
  query: z.string(),
}).transform((v) => {
  return remap$(v, {
    "filter_by_query": "filterByQuery",
    "number_of_buckets": "numberOfBuckets",
  });
});

/** @internal */
export type SearchAggregateInputBody$Outbound = {
  field: string;
  filter_by_query: boolean;
  number_of_buckets: number;
  query: string;
};

/** @internal */
export const SearchAggregateInputBody$outboundSchema: z.ZodType<
  SearchAggregateInputBody$Outbound,
  z.ZodTypeDef,
  SearchAggregateInputBody
> = z.object({
  field: z.string(),
  filterByQuery: z.boolean().default(false),
  numberOfBuckets: z.number().int(),
  query: z.string(),
}).transform((v) => {
  return remap$(v, {
    filterByQuery: "filter_by_query",
    numberOfBuckets: "number_of_buckets",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace SearchAggregateInputBody$ {
  /** @deprecated use `SearchAggregateInputBody$inboundSchema` instead. */
  export const inboundSchema = SearchAggregateInputBody$inboundSchema;
  /** @deprecated use `SearchAggregateInputBody$outboundSchema` instead. */
  export const outboundSchema = SearchAggregateInputBody$outboundSchema;
  /** @deprecated use `SearchAggregateInputBody$Outbound` instead. */
  export type Outbound = SearchAggregateInputBody$Outbound;
}

export function searchAggregateInputBodyToJSON(
  searchAggregateInputBody: SearchAggregateInputBody,
): string {
  return JSON.stringify(
    SearchAggregateInputBody$outboundSchema.parse(searchAggregateInputBody),
  );
}

export function searchAggregateInputBodyFromJSON(
  jsonString: string,
): SafeParseResult<SearchAggregateInputBody, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => SearchAggregateInputBody$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'SearchAggregateInputBody' from JSON`,
  );
}
