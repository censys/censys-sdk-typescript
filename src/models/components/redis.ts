/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  RedisRawOutput,
  RedisRawOutput$inboundSchema,
} from "./redisrawoutput.js";

export type Redis = {
  /**
   * The architecture bits (32 or 64) the Redis server used to build.
   */
  archBits?: string | undefined;
  /**
   * The response from the AUTH command, if sent.
   */
  authResponse?: string | undefined;
  /**
   * The Build ID of the Redis server.
   */
  buildId?: string | undefined;
  /**
   * The list of commands actually sent to the server, serialized in inline format, like 'PING' or 'AUTH somePassword'.
   */
  commands?: Array<string> | null | undefined;
  /**
   * The total number of commands processed by the server.
   */
  commandsProcessed?: number | undefined;
  /**
   * The total number of connections accepted by the server.
   */
  connectionsReceived?: number | undefined;
  /**
   * The version of the GCC compiler used to compile the Redis server.
   */
  gccVersion?: string | undefined;
  /**
   * The Sha-1 Git commit hash the Redis server used.
   */
  gitSha1?: string | undefined;
  /**
   * The response from the INFO command. Should be a series of key:value pairs separated by CRLFs.
   */
  infoResponse?: { [k: string]: string } | undefined;
  /**
   * Major is the version's major number.
   */
  major?: number | undefined;
  /**
   * The memory allocator.
   */
  memAllocator?: string | undefined;
  /**
   * Minor is the version's major number.
   */
  minor?: number | undefined;
  /**
   * The mode the Redis server is running (standalone or cluster), read from the the info_response (if available).
   */
  mode?: string | undefined;
  /**
   * The response from the NONEXISTENT command.
   */
  nonexistentResponse?: string | undefined;
  /**
   * The OS the Redis server is running, read from the the info_response (if available).
   */
  os?: string | undefined;
  /**
   * Patchlevel is the version's patchlevel number.
   */
  patchLevel?: number | undefined;
  /**
   * The response from the PING command; should either be "PONG" or an authentication error.
   */
  pingResponse?: string | undefined;
  /**
   * The response to the QUIT command.
   */
  quitResponse?: string | undefined;
  /**
   * The raw output returned by the server for each command sent; the indices match those of commands.
   */
  rawCommandOutput?: Array<RedisRawOutput> | null | undefined;
  /**
   * The number of seconds since Redis server start.
   */
  uptime?: number | undefined;
  /**
   * The total number of bytes allocated by Redis using its allocator.
   */
  usedMemory?: number | undefined;
};

/** @internal */
export const Redis$inboundSchema: z.ZodType<Redis, z.ZodTypeDef, unknown> = z
  .object({
    arch_bits: z.string().optional(),
    auth_response: z.string().optional(),
    build_id: z.string().optional(),
    commands: z.nullable(z.array(z.string())).optional(),
    commands_processed: z.number().int().optional(),
    connections_received: z.number().int().optional(),
    gcc_version: z.string().optional(),
    git_sha1: z.string().optional(),
    info_response: z.record(z.string()).optional(),
    major: z.number().int().optional(),
    mem_allocator: z.string().optional(),
    minor: z.number().int().optional(),
    mode: z.string().optional(),
    nonexistent_response: z.string().optional(),
    os: z.string().optional(),
    patch_level: z.number().int().optional(),
    ping_response: z.string().optional(),
    quit_response: z.string().optional(),
    raw_command_output: z.nullable(z.array(RedisRawOutput$inboundSchema))
      .optional(),
    uptime: z.number().int().optional(),
    used_memory: z.number().int().optional(),
  }).transform((v) => {
    return remap$(v, {
      "arch_bits": "archBits",
      "auth_response": "authResponse",
      "build_id": "buildId",
      "commands_processed": "commandsProcessed",
      "connections_received": "connectionsReceived",
      "gcc_version": "gccVersion",
      "git_sha1": "gitSha1",
      "info_response": "infoResponse",
      "mem_allocator": "memAllocator",
      "nonexistent_response": "nonexistentResponse",
      "patch_level": "patchLevel",
      "ping_response": "pingResponse",
      "quit_response": "quitResponse",
      "raw_command_output": "rawCommandOutput",
      "used_memory": "usedMemory",
    });
  });

export function redisFromJSON(
  jsonString: string,
): SafeParseResult<Redis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Redis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Redis' from JSON`,
  );
}
