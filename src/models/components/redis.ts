/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  RedisRawOutput,
  RedisRawOutput$inboundSchema,
  RedisRawOutput$Outbound,
  RedisRawOutput$outboundSchema,
} from "./redisrawoutput.js";

export type Redis = {
  /**
   * The architecture bits (32 or 64) the Redis server used to build.
   */
  archBits?: string | undefined;
  /**
   * The response from the AUTH command, if sent.
   */
  authResponse?: string | undefined;
  /**
   * The Build ID of the Redis server.
   */
  buildId?: string | undefined;
  /**
   * The list of commands actually sent to the server, serialized in inline format, like 'PING' or 'AUTH somePassword'.
   */
  commands?: Array<string> | null | undefined;
  /**
   * The total number of commands processed by the server.
   */
  commandsProcessed?: number | undefined;
  /**
   * The total number of connections accepted by the server.
   */
  connectionsReceived?: number | undefined;
  /**
   * The version of the GCC compiler used to compile the Redis server.
   */
  gccVersion?: string | undefined;
  /**
   * The Sha-1 Git commit hash the Redis server used.
   */
  gitSha1?: string | undefined;
  /**
   * The response from the INFO command. Should be a series of key:value pairs separated by CRLFs.
   */
  infoResponse?: { [k: string]: string } | undefined;
  /**
   * Major is the version's major number.
   */
  major?: number | undefined;
  /**
   * The memory allocator.
   */
  memAllocator?: string | undefined;
  /**
   * Minor is the version's major number.
   */
  minor?: number | undefined;
  /**
   * The mode the Redis server is running (standalone or cluster), read from the the info_response (if available).
   */
  mode?: string | undefined;
  /**
   * The response from the NONEXISTENT command.
   */
  nonexistentResponse?: string | undefined;
  /**
   * The OS the Redis server is running, read from the the info_response (if available).
   */
  os?: string | undefined;
  /**
   * Patchlevel is the version's patchlevel number.
   */
  patchLevel?: number | undefined;
  /**
   * The response from the PING command; should either be "PONG" or an authentication error.
   */
  pingResponse?: string | undefined;
  /**
   * The response to the QUIT command.
   */
  quitResponse?: string | undefined;
  /**
   * The raw output returned by the server for each command sent; the indices match those of commands.
   */
  rawCommandOutput?: Array<RedisRawOutput> | null | undefined;
  /**
   * The number of seconds since Redis server start.
   */
  uptime?: number | undefined;
  /**
   * The total number of bytes allocated by Redis using its allocator.
   */
  usedMemory?: number | undefined;
};

/** @internal */
export const Redis$inboundSchema: z.ZodType<Redis, z.ZodTypeDef, unknown> = z
  .object({
    arch_bits: z.string().optional(),
    auth_response: z.string().optional(),
    build_id: z.string().optional(),
    commands: z.nullable(z.array(z.string())).optional(),
    commands_processed: z.number().int().optional(),
    connections_received: z.number().int().optional(),
    gcc_version: z.string().optional(),
    git_sha1: z.string().optional(),
    info_response: z.record(z.string()).optional(),
    major: z.number().int().optional(),
    mem_allocator: z.string().optional(),
    minor: z.number().int().optional(),
    mode: z.string().optional(),
    nonexistent_response: z.string().optional(),
    os: z.string().optional(),
    patch_level: z.number().int().optional(),
    ping_response: z.string().optional(),
    quit_response: z.string().optional(),
    raw_command_output: z.nullable(z.array(RedisRawOutput$inboundSchema))
      .optional(),
    uptime: z.number().int().optional(),
    used_memory: z.number().int().optional(),
  }).transform((v) => {
    return remap$(v, {
      "arch_bits": "archBits",
      "auth_response": "authResponse",
      "build_id": "buildId",
      "commands_processed": "commandsProcessed",
      "connections_received": "connectionsReceived",
      "gcc_version": "gccVersion",
      "git_sha1": "gitSha1",
      "info_response": "infoResponse",
      "mem_allocator": "memAllocator",
      "nonexistent_response": "nonexistentResponse",
      "patch_level": "patchLevel",
      "ping_response": "pingResponse",
      "quit_response": "quitResponse",
      "raw_command_output": "rawCommandOutput",
      "used_memory": "usedMemory",
    });
  });

/** @internal */
export type Redis$Outbound = {
  arch_bits?: string | undefined;
  auth_response?: string | undefined;
  build_id?: string | undefined;
  commands?: Array<string> | null | undefined;
  commands_processed?: number | undefined;
  connections_received?: number | undefined;
  gcc_version?: string | undefined;
  git_sha1?: string | undefined;
  info_response?: { [k: string]: string } | undefined;
  major?: number | undefined;
  mem_allocator?: string | undefined;
  minor?: number | undefined;
  mode?: string | undefined;
  nonexistent_response?: string | undefined;
  os?: string | undefined;
  patch_level?: number | undefined;
  ping_response?: string | undefined;
  quit_response?: string | undefined;
  raw_command_output?: Array<RedisRawOutput$Outbound> | null | undefined;
  uptime?: number | undefined;
  used_memory?: number | undefined;
};

/** @internal */
export const Redis$outboundSchema: z.ZodType<
  Redis$Outbound,
  z.ZodTypeDef,
  Redis
> = z.object({
  archBits: z.string().optional(),
  authResponse: z.string().optional(),
  buildId: z.string().optional(),
  commands: z.nullable(z.array(z.string())).optional(),
  commandsProcessed: z.number().int().optional(),
  connectionsReceived: z.number().int().optional(),
  gccVersion: z.string().optional(),
  gitSha1: z.string().optional(),
  infoResponse: z.record(z.string()).optional(),
  major: z.number().int().optional(),
  memAllocator: z.string().optional(),
  minor: z.number().int().optional(),
  mode: z.string().optional(),
  nonexistentResponse: z.string().optional(),
  os: z.string().optional(),
  patchLevel: z.number().int().optional(),
  pingResponse: z.string().optional(),
  quitResponse: z.string().optional(),
  rawCommandOutput: z.nullable(z.array(RedisRawOutput$outboundSchema))
    .optional(),
  uptime: z.number().int().optional(),
  usedMemory: z.number().int().optional(),
}).transform((v) => {
  return remap$(v, {
    archBits: "arch_bits",
    authResponse: "auth_response",
    buildId: "build_id",
    commandsProcessed: "commands_processed",
    connectionsReceived: "connections_received",
    gccVersion: "gcc_version",
    gitSha1: "git_sha1",
    infoResponse: "info_response",
    memAllocator: "mem_allocator",
    nonexistentResponse: "nonexistent_response",
    patchLevel: "patch_level",
    pingResponse: "ping_response",
    quitResponse: "quit_response",
    rawCommandOutput: "raw_command_output",
    usedMemory: "used_memory",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Redis$ {
  /** @deprecated use `Redis$inboundSchema` instead. */
  export const inboundSchema = Redis$inboundSchema;
  /** @deprecated use `Redis$outboundSchema` instead. */
  export const outboundSchema = Redis$outboundSchema;
  /** @deprecated use `Redis$Outbound` instead. */
  export type Outbound = Redis$Outbound;
}

export function redisToJSON(redis: Redis): string {
  return JSON.stringify(Redis$outboundSchema.parse(redis));
}

export function redisFromJSON(
  jsonString: string,
): SafeParseResult<Redis, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Redis$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Redis' from JSON`,
  );
}
