/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  User,
  User$inboundSchema,
  User$Outbound,
  User$outboundSchema,
} from "./user.js";

export type Steam = {
  broadcastingActive?: boolean | undefined;
  connectPort?: number | undefined;
  contentCachePort?: number | undefined;
  downloadLanPeerGroup?: number | undefined;
  enabledServices?: number | undefined;
  euniverse?: number | undefined;
  gamesRunning?: boolean | undefined;
  hostname?: string | undefined;
  ipAddresses?: Array<string> | null | undefined;
  is64bit?: boolean | undefined;
  macAddresses?: Array<string> | null | undefined;
  minVersion?: number | undefined;
  ostype?: number | undefined;
  publicIpAddress?: string | undefined;
  remoteplayActive?: boolean | undefined;
  screenLocked?: boolean | undefined;
  steamDeck?: boolean | undefined;
  steamVersion?: string | undefined;
  supportedServices?: number | undefined;
  users?: Array<User> | null | undefined;
  version?: number | undefined;
  vrActive?: boolean | undefined;
  vrLinkCaps?: string | undefined;
};

/** @internal */
export const Steam$inboundSchema: z.ZodType<Steam, z.ZodTypeDef, unknown> = z
  .object({
    broadcasting_active: z.boolean().optional(),
    connect_port: z.number().int().optional(),
    content_cache_port: z.number().int().optional(),
    download_lan_peer_group: z.number().int().optional(),
    enabled_services: z.number().int().optional(),
    euniverse: z.number().int().optional(),
    games_running: z.boolean().optional(),
    hostname: z.string().optional(),
    ip_addresses: z.nullable(z.array(z.string())).optional(),
    is64bit: z.boolean().optional(),
    mac_addresses: z.nullable(z.array(z.string())).optional(),
    min_version: z.number().int().optional(),
    ostype: z.number().int().optional(),
    public_ip_address: z.string().optional(),
    remoteplay_active: z.boolean().optional(),
    screen_locked: z.boolean().optional(),
    steam_deck: z.boolean().optional(),
    steam_version: z.string().optional(),
    supported_services: z.number().int().optional(),
    users: z.nullable(z.array(User$inboundSchema)).optional(),
    version: z.number().int().optional(),
    vr_active: z.boolean().optional(),
    vr_link_caps: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "broadcasting_active": "broadcastingActive",
      "connect_port": "connectPort",
      "content_cache_port": "contentCachePort",
      "download_lan_peer_group": "downloadLanPeerGroup",
      "enabled_services": "enabledServices",
      "games_running": "gamesRunning",
      "ip_addresses": "ipAddresses",
      "mac_addresses": "macAddresses",
      "min_version": "minVersion",
      "public_ip_address": "publicIpAddress",
      "remoteplay_active": "remoteplayActive",
      "screen_locked": "screenLocked",
      "steam_deck": "steamDeck",
      "steam_version": "steamVersion",
      "supported_services": "supportedServices",
      "vr_active": "vrActive",
      "vr_link_caps": "vrLinkCaps",
    });
  });

/** @internal */
export type Steam$Outbound = {
  broadcasting_active?: boolean | undefined;
  connect_port?: number | undefined;
  content_cache_port?: number | undefined;
  download_lan_peer_group?: number | undefined;
  enabled_services?: number | undefined;
  euniverse?: number | undefined;
  games_running?: boolean | undefined;
  hostname?: string | undefined;
  ip_addresses?: Array<string> | null | undefined;
  is64bit?: boolean | undefined;
  mac_addresses?: Array<string> | null | undefined;
  min_version?: number | undefined;
  ostype?: number | undefined;
  public_ip_address?: string | undefined;
  remoteplay_active?: boolean | undefined;
  screen_locked?: boolean | undefined;
  steam_deck?: boolean | undefined;
  steam_version?: string | undefined;
  supported_services?: number | undefined;
  users?: Array<User$Outbound> | null | undefined;
  version?: number | undefined;
  vr_active?: boolean | undefined;
  vr_link_caps?: string | undefined;
};

/** @internal */
export const Steam$outboundSchema: z.ZodType<
  Steam$Outbound,
  z.ZodTypeDef,
  Steam
> = z.object({
  broadcastingActive: z.boolean().optional(),
  connectPort: z.number().int().optional(),
  contentCachePort: z.number().int().optional(),
  downloadLanPeerGroup: z.number().int().optional(),
  enabledServices: z.number().int().optional(),
  euniverse: z.number().int().optional(),
  gamesRunning: z.boolean().optional(),
  hostname: z.string().optional(),
  ipAddresses: z.nullable(z.array(z.string())).optional(),
  is64bit: z.boolean().optional(),
  macAddresses: z.nullable(z.array(z.string())).optional(),
  minVersion: z.number().int().optional(),
  ostype: z.number().int().optional(),
  publicIpAddress: z.string().optional(),
  remoteplayActive: z.boolean().optional(),
  screenLocked: z.boolean().optional(),
  steamDeck: z.boolean().optional(),
  steamVersion: z.string().optional(),
  supportedServices: z.number().int().optional(),
  users: z.nullable(z.array(User$outboundSchema)).optional(),
  version: z.number().int().optional(),
  vrActive: z.boolean().optional(),
  vrLinkCaps: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    broadcastingActive: "broadcasting_active",
    connectPort: "connect_port",
    contentCachePort: "content_cache_port",
    downloadLanPeerGroup: "download_lan_peer_group",
    enabledServices: "enabled_services",
    gamesRunning: "games_running",
    ipAddresses: "ip_addresses",
    macAddresses: "mac_addresses",
    minVersion: "min_version",
    publicIpAddress: "public_ip_address",
    remoteplayActive: "remoteplay_active",
    screenLocked: "screen_locked",
    steamDeck: "steam_deck",
    steamVersion: "steam_version",
    supportedServices: "supported_services",
    vrActive: "vr_active",
    vrLinkCaps: "vr_link_caps",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Steam$ {
  /** @deprecated use `Steam$inboundSchema` instead. */
  export const inboundSchema = Steam$inboundSchema;
  /** @deprecated use `Steam$outboundSchema` instead. */
  export const outboundSchema = Steam$outboundSchema;
  /** @deprecated use `Steam$Outbound` instead. */
  export type Outbound = Steam$Outbound;
}

export function steamToJSON(steam: Steam): string {
  return JSON.stringify(Steam$outboundSchema.parse(steam));
}

export function steamFromJSON(
  jsonString: string,
): SafeParseResult<Steam, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Steam$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Steam' from JSON`,
  );
}
