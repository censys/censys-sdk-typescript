/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { DesktopInfo, DesktopInfo$inboundSchema } from "./desktopinfo.js";
import { VncKeyValue, VncKeyValue$inboundSchema } from "./vnckeyvalue.js";

export type Vnc = {
  /**
   * If server terminates handshake, the reason offered (if any)
   */
  connectionFailedReason?: string | undefined;
  /**
   * Desktop name provided by the server, capped at 255 bytes
   */
  desktopName?: string | undefined;
  pixelEncoding?: VncKeyValue | undefined;
  screenInfo?: DesktopInfo | undefined;
  /**
   * server-specified security options
   */
  securityTypes?: Array<VncKeyValue> | null | undefined;
  version?: string | undefined;
};

/** @internal */
export const Vnc$inboundSchema: z.ZodType<Vnc, z.ZodTypeDef, unknown> = z
  .object({
    connection_failed_reason: z.string().optional(),
    desktop_name: z.string().optional(),
    pixel_encoding: VncKeyValue$inboundSchema.optional(),
    screen_info: DesktopInfo$inboundSchema.optional(),
    security_types: z.nullable(z.array(VncKeyValue$inboundSchema)).optional(),
    version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "connection_failed_reason": "connectionFailedReason",
      "desktop_name": "desktopName",
      "pixel_encoding": "pixelEncoding",
      "screen_info": "screenInfo",
      "security_types": "securityTypes",
    });
  });

export function vncFromJSON(
  jsonString: string,
): SafeParseResult<Vnc, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Vnc$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Vnc' from JSON`,
  );
}
