/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import * as openEnums from "../../types/enums.js";
import { OpenEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import { DnsEDns, DnsEDns$inboundSchema } from "./dnsedns.js";
import {
  DnsResourceRecord,
  DnsResourceRecord$inboundSchema,
} from "./dnsresourcerecord.js";

/**
 * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
 */
export const RCode = {
  Unknown: "",
  Success: "success",
  FormatError: "format_error",
  ServerFailure: "server_failure",
  NameError: "name_error",
  NotImplemented: "not_implemented",
  Refused: "refused",
  YxDomain: "yx_domain",
  YxRrset: "yx_rrset",
  NxRrset: "nx_rrset",
  NotAuth: "not_auth",
  NotZone: "not_zone",
  BadSig: "bad_sig",
  BadKey: "bad_key",
  BadTime: "bad_time",
  BadMode: "bad_mode",
  BadName: "bad_name",
  BadAlg: "bad_alg",
  BadTrunc: "bad_trunc",
  BadCookie: "bad_cookie",
} as const;
/**
 * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
 */
export type RCode = OpenEnum<typeof RCode>;

/**
 * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
 */
export const ServerType = {
  Unknown: "",
  RecursiveResolver: "recursive_resolver",
  Authoritative: "authoritative",
  Forwarding: "forwarding",
  Redirecting: "redirecting",
} as const;
/**
 * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
 */
export type ServerType = OpenEnum<typeof ServerType>;

export type Dns = {
  /**
   * A list of resource records (RRs) contained in the ADDITIONAL section of the response.
   */
  additionals?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A list of resource records (RRs) contained in the ANSWER section of the response.
   */
  answers?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A list of resource records (RRs) contained in the AUTHORITIES section of the response.
   */
  authorities?: Array<DnsResourceRecord> | null | undefined;
  edns?: DnsEDns | undefined;
  /**
   * A list of resource records (RRs) contained in the QUESTION section of the response, which may echo the request that the server is responding to.
   */
  questions?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
   */
  rCode?: RCode | undefined;
  /**
   * Whether the server returns an IP address for ip.parrotdns.com that matches the authoritative server, which is controlled by Censys.
   */
  resolvesCorrectly?: boolean | undefined;
  /**
   * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
   */
  serverType?: ServerType | undefined;
  version?: string | undefined;
};

/** @internal */
export const RCode$inboundSchema: z.ZodType<RCode, z.ZodTypeDef, unknown> =
  openEnums.inboundSchema(RCode);

/** @internal */
export const ServerType$inboundSchema: z.ZodType<
  ServerType,
  z.ZodTypeDef,
  unknown
> = openEnums.inboundSchema(ServerType);

/** @internal */
export const Dns$inboundSchema: z.ZodType<Dns, z.ZodTypeDef, unknown> = z
  .object({
    additionals: z.nullable(z.array(DnsResourceRecord$inboundSchema))
      .optional(),
    answers: z.nullable(z.array(DnsResourceRecord$inboundSchema)).optional(),
    authorities: z.nullable(z.array(DnsResourceRecord$inboundSchema))
      .optional(),
    edns: DnsEDns$inboundSchema.optional(),
    questions: z.nullable(z.array(DnsResourceRecord$inboundSchema)).optional(),
    r_code: RCode$inboundSchema.optional(),
    resolves_correctly: z.boolean().optional(),
    server_type: ServerType$inboundSchema.optional(),
    version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "r_code": "rCode",
      "resolves_correctly": "resolvesCorrectly",
      "server_type": "serverType",
    });
  });

export function dnsFromJSON(
  jsonString: string,
): SafeParseResult<Dns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Dns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Dns' from JSON`,
  );
}
