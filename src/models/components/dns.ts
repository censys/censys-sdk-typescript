/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  DnsEDns,
  DnsEDns$inboundSchema,
  DnsEDns$Outbound,
  DnsEDns$outboundSchema,
} from "./dnsedns.js";
import {
  DnsResourceRecord,
  DnsResourceRecord$inboundSchema,
  DnsResourceRecord$Outbound,
  DnsResourceRecord$outboundSchema,
} from "./dnsresourcerecord.js";

/**
 * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
 */
export const RCode = {
  UnknownCode: "unknown_code",
  Success: "success",
  FormatError: "format_error",
  ServerFailure: "server_failure",
  NameError: "name_error",
  NotImplemented: "not_implemented",
  Refused: "refused",
  YxDomain: "yx_domain",
  YxRrset: "yx_rrset",
  NxRrset: "nx_rrset",
  NotAuth: "not_auth",
  NotZone: "not_zone",
  BadSig: "bad_sig",
  BadKey: "bad_key",
  BadTime: "bad_time",
  BadMode: "bad_mode",
  BadName: "bad_name",
  BadAlg: "bad_alg",
  BadTrunc: "bad_trunc",
  BadCookie: "bad_cookie",
} as const;
/**
 * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
 */
export type RCode = ClosedEnum<typeof RCode>;

/**
 * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
 */
export const ServerType = {
  Unknown: "unknown",
  RecursiveResolver: "recursive_resolver",
  Authoritative: "authoritative",
  Forwarding: "forwarding",
  Redirecting: "redirecting",
} as const;
/**
 * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
 */
export type ServerType = ClosedEnum<typeof ServerType>;

export type Dns = {
  /**
   * A list of resource records (RRs) contained in the ADDITIONAL section of the response.
   */
  additionals?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A list of resource records (RRs) contained in the ANSWER section of the response.
   */
  answers?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A list of resource records (RRs) contained in the AUTHORITIES section of the response.
   */
  authorities?: Array<DnsResourceRecord> | null | undefined;
  edns?: DnsEDns | undefined;
  /**
   * A list of resource records (RRs) contained in the QUESTION section of the response, which may echo the request that the server is responding to.
   */
  questions?: Array<DnsResourceRecord> | null | undefined;
  /**
   * A enumerated field indicating the result of the request. The most common values are defined in RFC 1035.
   */
  rCode?: RCode | undefined;
  /**
   * Whether the server returns an IP address for ip.parrotdns.com that matches the authoritative server, which is controlled by Censys.
   */
  resolvesCorrectly?: boolean | undefined;
  /**
   * An enumerated value indicating the behavior of the server. An AUTHORITATIVE server fulfills requests for domain names it controls, which are not listed by the server. FORWARDING and RECURSIVE_RESOLVER servers fulfill requests indirectly for domain names they do not control. A RECURSIVE_RESOLVER will query ip.parrotdns.com itself, resulting in its own IP address being present in the dns.answers.response field.
   */
  serverType?: ServerType | undefined;
  version?: string | undefined;
};

/** @internal */
export const RCode$inboundSchema: z.ZodNativeEnum<typeof RCode> = z.nativeEnum(
  RCode,
);

/** @internal */
export const RCode$outboundSchema: z.ZodNativeEnum<typeof RCode> =
  RCode$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RCode$ {
  /** @deprecated use `RCode$inboundSchema` instead. */
  export const inboundSchema = RCode$inboundSchema;
  /** @deprecated use `RCode$outboundSchema` instead. */
  export const outboundSchema = RCode$outboundSchema;
}

/** @internal */
export const ServerType$inboundSchema: z.ZodNativeEnum<typeof ServerType> = z
  .nativeEnum(ServerType);

/** @internal */
export const ServerType$outboundSchema: z.ZodNativeEnum<typeof ServerType> =
  ServerType$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace ServerType$ {
  /** @deprecated use `ServerType$inboundSchema` instead. */
  export const inboundSchema = ServerType$inboundSchema;
  /** @deprecated use `ServerType$outboundSchema` instead. */
  export const outboundSchema = ServerType$outboundSchema;
}

/** @internal */
export const Dns$inboundSchema: z.ZodType<Dns, z.ZodTypeDef, unknown> = z
  .object({
    additionals: z.nullable(z.array(DnsResourceRecord$inboundSchema))
      .optional(),
    answers: z.nullable(z.array(DnsResourceRecord$inboundSchema)).optional(),
    authorities: z.nullable(z.array(DnsResourceRecord$inboundSchema))
      .optional(),
    edns: DnsEDns$inboundSchema.optional(),
    questions: z.nullable(z.array(DnsResourceRecord$inboundSchema)).optional(),
    r_code: RCode$inboundSchema.optional(),
    resolves_correctly: z.boolean().optional(),
    server_type: ServerType$inboundSchema.optional(),
    version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "r_code": "rCode",
      "resolves_correctly": "resolvesCorrectly",
      "server_type": "serverType",
    });
  });

/** @internal */
export type Dns$Outbound = {
  additionals?: Array<DnsResourceRecord$Outbound> | null | undefined;
  answers?: Array<DnsResourceRecord$Outbound> | null | undefined;
  authorities?: Array<DnsResourceRecord$Outbound> | null | undefined;
  edns?: DnsEDns$Outbound | undefined;
  questions?: Array<DnsResourceRecord$Outbound> | null | undefined;
  r_code?: string | undefined;
  resolves_correctly?: boolean | undefined;
  server_type?: string | undefined;
  version?: string | undefined;
};

/** @internal */
export const Dns$outboundSchema: z.ZodType<Dns$Outbound, z.ZodTypeDef, Dns> = z
  .object({
    additionals: z.nullable(z.array(DnsResourceRecord$outboundSchema))
      .optional(),
    answers: z.nullable(z.array(DnsResourceRecord$outboundSchema)).optional(),
    authorities: z.nullable(z.array(DnsResourceRecord$outboundSchema))
      .optional(),
    edns: DnsEDns$outboundSchema.optional(),
    questions: z.nullable(z.array(DnsResourceRecord$outboundSchema)).optional(),
    rCode: RCode$outboundSchema.optional(),
    resolvesCorrectly: z.boolean().optional(),
    serverType: ServerType$outboundSchema.optional(),
    version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      rCode: "r_code",
      resolvesCorrectly: "resolves_correctly",
      serverType: "server_type",
    });
  });

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Dns$ {
  /** @deprecated use `Dns$inboundSchema` instead. */
  export const inboundSchema = Dns$inboundSchema;
  /** @deprecated use `Dns$outboundSchema` instead. */
  export const outboundSchema = Dns$outboundSchema;
  /** @deprecated use `Dns$Outbound` instead. */
  export type Outbound = Dns$Outbound;
}

export function dnsToJSON(dns: Dns): string {
  return JSON.stringify(Dns$outboundSchema.parse(dns));
}

export function dnsFromJSON(
  jsonString: string,
): SafeParseResult<Dns, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Dns$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Dns' from JSON`,
  );
}
