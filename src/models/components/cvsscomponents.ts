/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * Indicates conditions beyond the attacker’s control that must exist in order to exploit the vulnerability. The Attack Complexity metric is scored as either Low or High. There are two possible values: Low (L) – There are no specific pre-conditions required for exploitation, High (H) – The attacker must complete some number of preparatory steps in order to get access.
 */
export const AttackComplexity = {
  Unspecified: "unspecified",
  Low: "low",
  High: "high",
} as const;
/**
 * Indicates conditions beyond the attacker’s control that must exist in order to exploit the vulnerability. The Attack Complexity metric is scored as either Low or High. There are two possible values: Low (L) – There are no specific pre-conditions required for exploitation, High (H) – The attacker must complete some number of preparatory steps in order to get access.
 */
export type AttackComplexity = ClosedEnum<typeof AttackComplexity>;

/**
 * Indicates the level of access required for an attacker to exploit the vulnerability. The Attack Vector metric is scored in one of four levels: Network (N) – Vulnerabilities with this rating are remotely exploitable, from one or more hops away, up to, and including, remote exploitation over the Internet, Adjacent (A) – A vulnerability with this rating requires network adjacency for exploitation. The attack must be launched from the same physical or logical network, Local (L) – Vulnerabilities with this rating are not exploitable over a network, Physical (P) – An attacker must physically interact with the target system.
 */
export const AttackVector = {
  Unspecified: "unspecified",
  Network: "network",
  Adjacent: "adjacent",
  Local: "local",
  Physical: "physical",
} as const;
/**
 * Indicates the level of access required for an attacker to exploit the vulnerability. The Attack Vector metric is scored in one of four levels: Network (N) – Vulnerabilities with this rating are remotely exploitable, from one or more hops away, up to, and including, remote exploitation over the Internet, Adjacent (A) – A vulnerability with this rating requires network adjacency for exploitation. The attack must be launched from the same physical or logical network, Local (L) – Vulnerabilities with this rating are not exploitable over a network, Physical (P) – An attacker must physically interact with the target system.
 */
export type AttackVector = ClosedEnum<typeof AttackVector>;

/**
 * If an attack renders information unavailable, such as when a system crashes or through a DDoS attack, availability is negatively impacted. Availability has three possible values: None (N) – There is no loss of availability, Low (L) – Availability might be intermittently limited, or performance might be negatively impacted, as a result of a successful attack, High (H) – There is a complete loss of availability of the impacted system or information.
 */
export const Availability = {
  Unspecified: "unspecified",
  None: "none",
  Low: "low",
  High: "high",
} as const;
/**
 * If an attack renders information unavailable, such as when a system crashes or through a DDoS attack, availability is negatively impacted. Availability has three possible values: None (N) – There is no loss of availability, Low (L) – Availability might be intermittently limited, or performance might be negatively impacted, as a result of a successful attack, High (H) – There is a complete loss of availability of the impacted system or information.
 */
export type Availability = ClosedEnum<typeof Availability>;

/**
 * Refers to the disclosure of sensitive information to authorized and unauthorized users, with the goal being that only authorized users are able to access the target data. Confidentiality has three potential values: High (H) – The attacker has full access to all resources in the impacted system, including highly sensitive information such as encryption keys, Low (L) – The attacker has partial access to information, with no control over what, specifically, they are able to access, None (N) – No data is accessible to unauthorized users as a result of the exploit.
 */
export const Confidentiality = {
  Unspecified: "unspecified",
  None: "none",
  Low: "low",
  High: "high",
} as const;
/**
 * Refers to the disclosure of sensitive information to authorized and unauthorized users, with the goal being that only authorized users are able to access the target data. Confidentiality has three potential values: High (H) – The attacker has full access to all resources in the impacted system, including highly sensitive information such as encryption keys, Low (L) – The attacker has partial access to information, with no control over what, specifically, they are able to access, None (N) – No data is accessible to unauthorized users as a result of the exploit.
 */
export type Confidentiality = ClosedEnum<typeof Confidentiality>;

/**
 * Refers to whether the protected information has been tampered with or changed in any way. If there is no way for an attacker to alter the accuracy or completeness of the information, integrity has been maintained. Integrity has three values: None (N) – There is no loss of the integrity of any information, Low (L) – A limited amount of information might be tampered with or modified, but there is no serious impact on the protected system, High (H) – The attacker can modify any/all information on the target system, resulting in a complete loss of integrity.
 */
export const Integrity = {
  Unspecified: "unspecified",
  None: "none",
  Low: "low",
  High: "high",
} as const;
/**
 * Refers to whether the protected information has been tampered with or changed in any way. If there is no way for an attacker to alter the accuracy or completeness of the information, integrity has been maintained. Integrity has three values: None (N) – There is no loss of the integrity of any information, Low (L) – A limited amount of information might be tampered with or modified, but there is no serious impact on the protected system, High (H) – The attacker can modify any/all information on the target system, resulting in a complete loss of integrity.
 */
export type Integrity = ClosedEnum<typeof Integrity>;

/**
 * Describes the level of privileges or access an attacker must have before successful exploitation. There are three possible values: None (N) – There is no privilege or special access required to conduct the attack, Low (L) – The attacker requires basic, “user” level privileges to leverage the exploit, High (H) – Administrative or similar access privileges are required for successful attack.
 */
export const PrivilegesRequired = {
  Unspecified: "unspecified",
  None: "none",
  Low: "low",
  High: "high",
} as const;
/**
 * Describes the level of privileges or access an attacker must have before successful exploitation. There are three possible values: None (N) – There is no privilege or special access required to conduct the attack, Low (L) – The attacker requires basic, “user” level privileges to leverage the exploit, High (H) – Administrative or similar access privileges are required for successful attack.
 */
export type PrivilegesRequired = ClosedEnum<typeof PrivilegesRequired>;

/**
 * Determines whether a vulnerability in one system or component can impact another system or component. If a vulnerability in a vulnerable component can affect a component which is in a different security scope than the vulnerable component, a scope change occurs. Scope has two possible ratings: Changed (C) – An exploited vulnerability can have a carry over impact on another system, Unchanged (U) – The exploited vulnerability is limited in damage to only the local security authority.
 */
export const Scope = {
  Unspecified: "unspecified",
  Unchanged: "unchanged",
  Changed: "changed",
} as const;
/**
 * Determines whether a vulnerability in one system or component can impact another system or component. If a vulnerability in a vulnerable component can affect a component which is in a different security scope than the vulnerable component, a scope change occurs. Scope has two possible ratings: Changed (C) – An exploited vulnerability can have a carry over impact on another system, Unchanged (U) – The exploited vulnerability is limited in damage to only the local security authority.
 */
export type Scope = ClosedEnum<typeof Scope>;

/**
 * Describes whether a user, other than the attacker, is required to do anything or participate in exploitation of the vulnerability. User interaction has two possible values: None (N) – No user interaction is required, Required (R) – A user must complete some steps for the exploit to succeed. For example, a user might be required to install some software.
 */
export const UserInteraction = {
  Unspecified: "unspecified",
  None: "none",
  Required: "required",
} as const;
/**
 * Describes whether a user, other than the attacker, is required to do anything or participate in exploitation of the vulnerability. User interaction has two possible values: None (N) – No user interaction is required, Required (R) – A user must complete some steps for the exploit to succeed. For example, a user might be required to install some software.
 */
export type UserInteraction = ClosedEnum<typeof UserInteraction>;

export type CVSSComponents = {
  /**
   * Indicates conditions beyond the attacker’s control that must exist in order to exploit the vulnerability. The Attack Complexity metric is scored as either Low or High. There are two possible values: Low (L) – There are no specific pre-conditions required for exploitation, High (H) – The attacker must complete some number of preparatory steps in order to get access.
   */
  attackComplexity?: AttackComplexity | undefined;
  /**
   * Indicates the level of access required for an attacker to exploit the vulnerability. The Attack Vector metric is scored in one of four levels: Network (N) – Vulnerabilities with this rating are remotely exploitable, from one or more hops away, up to, and including, remote exploitation over the Internet, Adjacent (A) – A vulnerability with this rating requires network adjacency for exploitation. The attack must be launched from the same physical or logical network, Local (L) – Vulnerabilities with this rating are not exploitable over a network, Physical (P) – An attacker must physically interact with the target system.
   */
  attackVector?: AttackVector | undefined;
  /**
   * If an attack renders information unavailable, such as when a system crashes or through a DDoS attack, availability is negatively impacted. Availability has three possible values: None (N) – There is no loss of availability, Low (L) – Availability might be intermittently limited, or performance might be negatively impacted, as a result of a successful attack, High (H) – There is a complete loss of availability of the impacted system or information.
   */
  availability?: Availability | undefined;
  /**
   * Refers to the disclosure of sensitive information to authorized and unauthorized users, with the goal being that only authorized users are able to access the target data. Confidentiality has three potential values: High (H) – The attacker has full access to all resources in the impacted system, including highly sensitive information such as encryption keys, Low (L) – The attacker has partial access to information, with no control over what, specifically, they are able to access, None (N) – No data is accessible to unauthorized users as a result of the exploit.
   */
  confidentiality?: Confidentiality | undefined;
  /**
   * Refers to whether the protected information has been tampered with or changed in any way. If there is no way for an attacker to alter the accuracy or completeness of the information, integrity has been maintained. Integrity has three values: None (N) – There is no loss of the integrity of any information, Low (L) – A limited amount of information might be tampered with or modified, but there is no serious impact on the protected system, High (H) – The attacker can modify any/all information on the target system, resulting in a complete loss of integrity.
   */
  integrity?: Integrity | undefined;
  /**
   * Describes the level of privileges or access an attacker must have before successful exploitation. There are three possible values: None (N) – There is no privilege or special access required to conduct the attack, Low (L) – The attacker requires basic, “user” level privileges to leverage the exploit, High (H) – Administrative or similar access privileges are required for successful attack.
   */
  privilegesRequired?: PrivilegesRequired | undefined;
  /**
   * Determines whether a vulnerability in one system or component can impact another system or component. If a vulnerability in a vulnerable component can affect a component which is in a different security scope than the vulnerable component, a scope change occurs. Scope has two possible ratings: Changed (C) – An exploited vulnerability can have a carry over impact on another system, Unchanged (U) – The exploited vulnerability is limited in damage to only the local security authority.
   */
  scope?: Scope | undefined;
  /**
   * Describes whether a user, other than the attacker, is required to do anything or participate in exploitation of the vulnerability. User interaction has two possible values: None (N) – No user interaction is required, Required (R) – A user must complete some steps for the exploit to succeed. For example, a user might be required to install some software.
   */
  userInteraction?: UserInteraction | undefined;
};

/** @internal */
export const AttackComplexity$inboundSchema: z.ZodNativeEnum<
  typeof AttackComplexity
> = z.nativeEnum(AttackComplexity);

/** @internal */
export const AttackComplexity$outboundSchema: z.ZodNativeEnum<
  typeof AttackComplexity
> = AttackComplexity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttackComplexity$ {
  /** @deprecated use `AttackComplexity$inboundSchema` instead. */
  export const inboundSchema = AttackComplexity$inboundSchema;
  /** @deprecated use `AttackComplexity$outboundSchema` instead. */
  export const outboundSchema = AttackComplexity$outboundSchema;
}

/** @internal */
export const AttackVector$inboundSchema: z.ZodNativeEnum<typeof AttackVector> =
  z.nativeEnum(AttackVector);

/** @internal */
export const AttackVector$outboundSchema: z.ZodNativeEnum<typeof AttackVector> =
  AttackVector$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace AttackVector$ {
  /** @deprecated use `AttackVector$inboundSchema` instead. */
  export const inboundSchema = AttackVector$inboundSchema;
  /** @deprecated use `AttackVector$outboundSchema` instead. */
  export const outboundSchema = AttackVector$outboundSchema;
}

/** @internal */
export const Availability$inboundSchema: z.ZodNativeEnum<typeof Availability> =
  z.nativeEnum(Availability);

/** @internal */
export const Availability$outboundSchema: z.ZodNativeEnum<typeof Availability> =
  Availability$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Availability$ {
  /** @deprecated use `Availability$inboundSchema` instead. */
  export const inboundSchema = Availability$inboundSchema;
  /** @deprecated use `Availability$outboundSchema` instead. */
  export const outboundSchema = Availability$outboundSchema;
}

/** @internal */
export const Confidentiality$inboundSchema: z.ZodNativeEnum<
  typeof Confidentiality
> = z.nativeEnum(Confidentiality);

/** @internal */
export const Confidentiality$outboundSchema: z.ZodNativeEnum<
  typeof Confidentiality
> = Confidentiality$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Confidentiality$ {
  /** @deprecated use `Confidentiality$inboundSchema` instead. */
  export const inboundSchema = Confidentiality$inboundSchema;
  /** @deprecated use `Confidentiality$outboundSchema` instead. */
  export const outboundSchema = Confidentiality$outboundSchema;
}

/** @internal */
export const Integrity$inboundSchema: z.ZodNativeEnum<typeof Integrity> = z
  .nativeEnum(Integrity);

/** @internal */
export const Integrity$outboundSchema: z.ZodNativeEnum<typeof Integrity> =
  Integrity$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Integrity$ {
  /** @deprecated use `Integrity$inboundSchema` instead. */
  export const inboundSchema = Integrity$inboundSchema;
  /** @deprecated use `Integrity$outboundSchema` instead. */
  export const outboundSchema = Integrity$outboundSchema;
}

/** @internal */
export const PrivilegesRequired$inboundSchema: z.ZodNativeEnum<
  typeof PrivilegesRequired
> = z.nativeEnum(PrivilegesRequired);

/** @internal */
export const PrivilegesRequired$outboundSchema: z.ZodNativeEnum<
  typeof PrivilegesRequired
> = PrivilegesRequired$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace PrivilegesRequired$ {
  /** @deprecated use `PrivilegesRequired$inboundSchema` instead. */
  export const inboundSchema = PrivilegesRequired$inboundSchema;
  /** @deprecated use `PrivilegesRequired$outboundSchema` instead. */
  export const outboundSchema = PrivilegesRequired$outboundSchema;
}

/** @internal */
export const Scope$inboundSchema: z.ZodNativeEnum<typeof Scope> = z.nativeEnum(
  Scope,
);

/** @internal */
export const Scope$outboundSchema: z.ZodNativeEnum<typeof Scope> =
  Scope$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Scope$ {
  /** @deprecated use `Scope$inboundSchema` instead. */
  export const inboundSchema = Scope$inboundSchema;
  /** @deprecated use `Scope$outboundSchema` instead. */
  export const outboundSchema = Scope$outboundSchema;
}

/** @internal */
export const UserInteraction$inboundSchema: z.ZodNativeEnum<
  typeof UserInteraction
> = z.nativeEnum(UserInteraction);

/** @internal */
export const UserInteraction$outboundSchema: z.ZodNativeEnum<
  typeof UserInteraction
> = UserInteraction$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace UserInteraction$ {
  /** @deprecated use `UserInteraction$inboundSchema` instead. */
  export const inboundSchema = UserInteraction$inboundSchema;
  /** @deprecated use `UserInteraction$outboundSchema` instead. */
  export const outboundSchema = UserInteraction$outboundSchema;
}

/** @internal */
export const CVSSComponents$inboundSchema: z.ZodType<
  CVSSComponents,
  z.ZodTypeDef,
  unknown
> = z.object({
  attack_complexity: AttackComplexity$inboundSchema.optional(),
  attack_vector: AttackVector$inboundSchema.optional(),
  availability: Availability$inboundSchema.optional(),
  confidentiality: Confidentiality$inboundSchema.optional(),
  integrity: Integrity$inboundSchema.optional(),
  privileges_required: PrivilegesRequired$inboundSchema.optional(),
  scope: Scope$inboundSchema.optional(),
  user_interaction: UserInteraction$inboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    "attack_complexity": "attackComplexity",
    "attack_vector": "attackVector",
    "privileges_required": "privilegesRequired",
    "user_interaction": "userInteraction",
  });
});

/** @internal */
export type CVSSComponents$Outbound = {
  attack_complexity?: string | undefined;
  attack_vector?: string | undefined;
  availability?: string | undefined;
  confidentiality?: string | undefined;
  integrity?: string | undefined;
  privileges_required?: string | undefined;
  scope?: string | undefined;
  user_interaction?: string | undefined;
};

/** @internal */
export const CVSSComponents$outboundSchema: z.ZodType<
  CVSSComponents$Outbound,
  z.ZodTypeDef,
  CVSSComponents
> = z.object({
  attackComplexity: AttackComplexity$outboundSchema.optional(),
  attackVector: AttackVector$outboundSchema.optional(),
  availability: Availability$outboundSchema.optional(),
  confidentiality: Confidentiality$outboundSchema.optional(),
  integrity: Integrity$outboundSchema.optional(),
  privilegesRequired: PrivilegesRequired$outboundSchema.optional(),
  scope: Scope$outboundSchema.optional(),
  userInteraction: UserInteraction$outboundSchema.optional(),
}).transform((v) => {
  return remap$(v, {
    attackComplexity: "attack_complexity",
    attackVector: "attack_vector",
    privilegesRequired: "privileges_required",
    userInteraction: "user_interaction",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CVSSComponents$ {
  /** @deprecated use `CVSSComponents$inboundSchema` instead. */
  export const inboundSchema = CVSSComponents$inboundSchema;
  /** @deprecated use `CVSSComponents$outboundSchema` instead. */
  export const outboundSchema = CVSSComponents$outboundSchema;
  /** @deprecated use `CVSSComponents$Outbound` instead. */
  export type Outbound = CVSSComponents$Outbound;
}

export function cvssComponentsToJSON(cvssComponents: CVSSComponents): string {
  return JSON.stringify(CVSSComponents$outboundSchema.parse(cvssComponents));
}

export function cvssComponentsFromJSON(
  jsonString: string,
): SafeParseResult<CVSSComponents, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CVSSComponents$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CVSSComponents' from JSON`,
  );
}
