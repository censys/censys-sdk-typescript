/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  OracleDescriptor,
  OracleDescriptor$inboundSchema,
  OracleDescriptor$Outbound,
  OracleDescriptor$outboundSchema,
} from "./oracledescriptor.js";

export type Oracle = {
  /**
   * The version declared by the service when it accepts the handshake, if applicable.
   */
  acceptVersion?: number | undefined;
  /**
   * The first set of ConnectFlags returned in the Accept packet.
   */
  connectFlags0?: { [k: string]: boolean } | undefined;
  /**
   * The second set of ConnectFlags returned in the Accept packet.
   */
  connectFlags1?: { [k: string]: boolean } | undefined;
  /**
   * Whether the server requested that the scanner resend its initial connection packet.
   */
  didResend?: boolean | undefined;
  /**
   * Set of flags that the server returns in the Accept packet.
   */
  globalServiceOptions?: { [k: string]: boolean } | undefined;
  /**
   * A map from the native Service Negotation service names to the ReleaseVersion (in dotted-decimal format) in that service packet.
   */
  nsnServiceVersions?: { [k: string]: string } | undefined;
  /**
   * The version string in the root of the native service negotiation packet, if applicable.
   */
  nsnVersion?: string | undefined;
  /**
   * The parsed descriptor returned by the server in the Refuse packet; it is empty if the server does not return a Refuse packet. The keys are strings like 'DESCRIPTION.ERROR_STACK.ERROR.CODE
   */
  refuseError?: Array<OracleDescriptor> | null | undefined;
  /**
   * The unparsed error received when the initial handshake is refused.
   */
  refuseErrorRaw?: string | undefined;
  /**
   * The 'AppReason' returned by the server in the RefusePacket, as an 8-bit unsigned hex string.
   */
  refuseReasonApp?: string | undefined;
  /**
   * The 'SysReason' returned by the server in the RefusePacket, as an 8-bit unsigned hex string.
   */
  refuseReasonSys?: string | undefined;
  /**
   * The version declared by the service when it refuses the handshake, if applicable.
   */
  refuseVersion?: string | undefined;
};

/** @internal */
export const Oracle$inboundSchema: z.ZodType<Oracle, z.ZodTypeDef, unknown> = z
  .object({
    accept_version: z.number().int().optional(),
    connect_flags0: z.record(z.boolean()).optional(),
    connect_flags1: z.record(z.boolean()).optional(),
    did_resend: z.boolean().optional(),
    global_service_options: z.record(z.boolean()).optional(),
    nsn_service_versions: z.record(z.string()).optional(),
    nsn_version: z.string().optional(),
    refuse_error: z.nullable(z.array(OracleDescriptor$inboundSchema))
      .optional(),
    refuse_error_raw: z.string().optional(),
    refuse_reason_app: z.string().optional(),
    refuse_reason_sys: z.string().optional(),
    refuse_version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "accept_version": "acceptVersion",
      "connect_flags0": "connectFlags0",
      "connect_flags1": "connectFlags1",
      "did_resend": "didResend",
      "global_service_options": "globalServiceOptions",
      "nsn_service_versions": "nsnServiceVersions",
      "nsn_version": "nsnVersion",
      "refuse_error": "refuseError",
      "refuse_error_raw": "refuseErrorRaw",
      "refuse_reason_app": "refuseReasonApp",
      "refuse_reason_sys": "refuseReasonSys",
      "refuse_version": "refuseVersion",
    });
  });

/** @internal */
export type Oracle$Outbound = {
  accept_version?: number | undefined;
  connect_flags0?: { [k: string]: boolean } | undefined;
  connect_flags1?: { [k: string]: boolean } | undefined;
  did_resend?: boolean | undefined;
  global_service_options?: { [k: string]: boolean } | undefined;
  nsn_service_versions?: { [k: string]: string } | undefined;
  nsn_version?: string | undefined;
  refuse_error?: Array<OracleDescriptor$Outbound> | null | undefined;
  refuse_error_raw?: string | undefined;
  refuse_reason_app?: string | undefined;
  refuse_reason_sys?: string | undefined;
  refuse_version?: string | undefined;
};

/** @internal */
export const Oracle$outboundSchema: z.ZodType<
  Oracle$Outbound,
  z.ZodTypeDef,
  Oracle
> = z.object({
  acceptVersion: z.number().int().optional(),
  connectFlags0: z.record(z.boolean()).optional(),
  connectFlags1: z.record(z.boolean()).optional(),
  didResend: z.boolean().optional(),
  globalServiceOptions: z.record(z.boolean()).optional(),
  nsnServiceVersions: z.record(z.string()).optional(),
  nsnVersion: z.string().optional(),
  refuseError: z.nullable(z.array(OracleDescriptor$outboundSchema)).optional(),
  refuseErrorRaw: z.string().optional(),
  refuseReasonApp: z.string().optional(),
  refuseReasonSys: z.string().optional(),
  refuseVersion: z.string().optional(),
}).transform((v) => {
  return remap$(v, {
    acceptVersion: "accept_version",
    connectFlags0: "connect_flags0",
    connectFlags1: "connect_flags1",
    didResend: "did_resend",
    globalServiceOptions: "global_service_options",
    nsnServiceVersions: "nsn_service_versions",
    nsnVersion: "nsn_version",
    refuseError: "refuse_error",
    refuseErrorRaw: "refuse_error_raw",
    refuseReasonApp: "refuse_reason_app",
    refuseReasonSys: "refuse_reason_sys",
    refuseVersion: "refuse_version",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Oracle$ {
  /** @deprecated use `Oracle$inboundSchema` instead. */
  export const inboundSchema = Oracle$inboundSchema;
  /** @deprecated use `Oracle$outboundSchema` instead. */
  export const outboundSchema = Oracle$outboundSchema;
  /** @deprecated use `Oracle$Outbound` instead. */
  export type Outbound = Oracle$Outbound;
}

export function oracleToJSON(oracle: Oracle): string {
  return JSON.stringify(Oracle$outboundSchema.parse(oracle));
}

export function oracleFromJSON(
  jsonString: string,
): SafeParseResult<Oracle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Oracle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Oracle' from JSON`,
  );
}
