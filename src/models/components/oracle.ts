/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod/v3";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  OracleDescriptor,
  OracleDescriptor$inboundSchema,
} from "./oracledescriptor.js";

export type Oracle = {
  /**
   * The version declared by the service when it accepts the handshake, if applicable.
   */
  acceptVersion?: number | undefined;
  /**
   * The first set of ConnectFlags returned in the Accept packet.
   */
  connectFlags0?: { [k: string]: boolean } | undefined;
  /**
   * The second set of ConnectFlags returned in the Accept packet.
   */
  connectFlags1?: { [k: string]: boolean } | undefined;
  /**
   * Whether the server requested that the scanner resend its initial connection packet.
   */
  didResend?: boolean | undefined;
  /**
   * Set of flags that the server returns in the Accept packet.
   */
  globalServiceOptions?: { [k: string]: boolean } | undefined;
  /**
   * A map from the native Service Negotation service names to the ReleaseVersion (in dotted-decimal format) in that service packet.
   */
  nsnServiceVersions?: { [k: string]: string } | undefined;
  /**
   * The version string in the root of the native service negotiation packet, if applicable.
   */
  nsnVersion?: string | undefined;
  /**
   * The parsed descriptor returned by the server in the Refuse packet; it is empty if the server does not return a Refuse packet. The keys are strings like 'DESCRIPTION.ERROR_STACK.ERROR.CODE
   */
  refuseError?: Array<OracleDescriptor> | null | undefined;
  /**
   * The unparsed error received when the initial handshake is refused.
   */
  refuseErrorRaw?: string | undefined;
  /**
   * The 'AppReason' returned by the server in the RefusePacket, as an 8-bit unsigned hex string.
   */
  refuseReasonApp?: string | undefined;
  /**
   * The 'SysReason' returned by the server in the RefusePacket, as an 8-bit unsigned hex string.
   */
  refuseReasonSys?: string | undefined;
  /**
   * The version declared by the service when it refuses the handshake, if applicable.
   */
  refuseVersion?: string | undefined;
};

/** @internal */
export const Oracle$inboundSchema: z.ZodType<Oracle, z.ZodTypeDef, unknown> = z
  .object({
    accept_version: z.number().int().optional(),
    connect_flags0: z.record(z.boolean()).optional(),
    connect_flags1: z.record(z.boolean()).optional(),
    did_resend: z.boolean().optional(),
    global_service_options: z.record(z.boolean()).optional(),
    nsn_service_versions: z.record(z.string()).optional(),
    nsn_version: z.string().optional(),
    refuse_error: z.nullable(z.array(OracleDescriptor$inboundSchema))
      .optional(),
    refuse_error_raw: z.string().optional(),
    refuse_reason_app: z.string().optional(),
    refuse_reason_sys: z.string().optional(),
    refuse_version: z.string().optional(),
  }).transform((v) => {
    return remap$(v, {
      "accept_version": "acceptVersion",
      "connect_flags0": "connectFlags0",
      "connect_flags1": "connectFlags1",
      "did_resend": "didResend",
      "global_service_options": "globalServiceOptions",
      "nsn_service_versions": "nsnServiceVersions",
      "nsn_version": "nsnVersion",
      "refuse_error": "refuseError",
      "refuse_error_raw": "refuseErrorRaw",
      "refuse_reason_app": "refuseReasonApp",
      "refuse_reason_sys": "refuseReasonSys",
      "refuse_version": "refuseVersion",
    });
  });

export function oracleFromJSON(
  jsonString: string,
): SafeParseResult<Oracle, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Oracle$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Oracle' from JSON`,
  );
}
